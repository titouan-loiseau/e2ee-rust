use e2ee_rust_common::{
    crypto::{
        aead::{aes256gcm::AES256GCM, traits::AEADScheme},
        curve::{curve25519::Curve25519, traits::EllipticCurveAlgorithm},
        pqkem::{crystalskyber512::CrystalsKyber512, traits::PQKEMAlgorithm},
    },
    errors::{aead::AEADError, general::GeneralError},
    hash::enum_hash_types::HashType,
    pqxdh::{
        first_message::FirstMessage, kdf, prekey_bundle::PrekeyBundle,
        private_bundle::PrivateBundle, registration_bundle::RegistrationBundle,
    },
    utils::display::print_slice,
};
use log::{debug, info};
use zeroize::Zeroize;

// curve        A Montgomery curve for which XEdDSA is specified, at present this is one of curve25519 or curve448
const CURVE_TYPE: Curve25519 = Curve25519 {};

// hash         A 256 or 512-bit hash function (e.g. SHA-256 or SHA-512)
const HASH_TYPE: HashType = HashType::SHA256;

// info         An optional ASCII string with a maximum length of 255 bytesAn ASCII string identifying the application with a minimum length of 8 bytes
const INFO: &str = "PQXDHTestApplication";

// pqkem        A post-quantum key encapsulation mechanism that has IND-CCA post-quantum security (e.g. Crystals-Kyber-1024)
const PQKEM_TYPE: CrystalsKyber512 = CrystalsKyber512 {};

// aead         A scheme for authenticated encryption with associated data that has IND-CPA and INT-CTXT post-quantum security
const AEAD_TYPE: AES256GCM = AES256GCM {};

const ONE_TIME_CURVE_PREKEYS: usize = 10;
const ONE_TIME_PQKEM_PREKEYS: usize = 10;

// fn mainb() {
//     env_logger::init();
//     info!("Hello, world!");
// }

fn main() -> Result<(), GeneralError> {
    env_logger::init();
    let mut rng = rand::thread_rng();

    // Generate private bundles
    let alice_private_bundle = PrivateBundle::new(
        &CURVE_TYPE,
        &PQKEM_TYPE,
        ONE_TIME_CURVE_PREKEYS,
        ONE_TIME_PQKEM_PREKEYS,
        &mut rng,
    );
    debug!("Alice private bundle:");
    alice_private_bundle.print();

    let bob_private_bundle = PrivateBundle::new(
        &CURVE_TYPE,
        &PQKEM_TYPE,
        ONE_TIME_CURVE_PREKEYS,
        ONE_TIME_PQKEM_PREKEYS,
        &mut rng,
    );
    debug!("Bob private bundle:");
    bob_private_bundle.print();

    // Generate registration bundle for Bob
    let bob_registration_bundle =
        RegistrationBundle::from_private_bundle(&bob_private_bundle, &CURVE_TYPE, &mut rng)?;
    debug!("Bob registration bundle:");
    bob_registration_bundle.print();

    // Here it should be sent to the server
    let bob_registration_bundle_bytes = bob_registration_bundle.to_protobuf_bytes();
    debug!(
        "Bob registration bundle bytes len: {}",
        bob_registration_bundle_bytes.len()
    );

    // Alice gets the prekey bundle from the server
    let alice_prekey_bundle = PrekeyBundle::from_registration_bundle(&bob_registration_bundle);
    debug!("Alice prekey bundle:");
    alice_prekey_bundle.print();

    // Alice checks the signatures on the prekeys of the prekey bundle
    // Check the signature on the curve prekey
    info!("Checking signatures on the prekeys of the prekey bundle");
    if !CURVE_TYPE
        .xeddsa_verify(
            &alice_prekey_bundle.identity_key,
            &alice_prekey_bundle.curve_prekey.public_key.encode_ec(),
            &alice_prekey_bundle.curve_prekey_signature,
        )
        .map_err(|e| GeneralError::XedDSA(e))?
    {
        panic!("Invalid curve prekey signature");
    }
    info!("Curve prekey signature is valid");

    // Check the signature on the PQKEM prekey
    if !CURVE_TYPE
        .xeddsa_verify(
            &alice_prekey_bundle.identity_key,
            &alice_prekey_bundle
                .one_time_pqkem_prekey
                .public_key
                .encode_kem(),
            &alice_prekey_bundle.one_time_pqkem_prekey_signature,
        )
        .map_err(|e| GeneralError::XedDSA(e))?
    {
        panic!("Invalid PQKEM prekey signature");
    }
    info!("PQKEM prekey signature is valid");
    info!("Alice has verified the prekey bundle");

    // Alice generates an ephemeral key pair
    let mut alice_ephemeral_key_pair = CURVE_TYPE.generate_key_pair(&mut rng);
    debug!(
        "Alice ephemeral key: {}",
        alice_ephemeral_key_pair.public_key.print_key()
    );

    // Alice encapsulates the PQKEM prekey
    let (pqkem_ciphertext, mut shared_secret_alice) = PQKEM_TYPE.encapsulate(
        alice_prekey_bundle
            .one_time_pqkem_prekey
            .public_key
            .bytes
            .as_slice(),
        &mut rng,
    )
    .map_err(|e| GeneralError::PQKEM(e))?;
    debug!(
        "Encapsulated PQKEM prekey: {}",
        print_slice(&pqkem_ciphertext)
    );
    debug!(
        "Shared secret (Alice): {}",
        print_slice(&shared_secret_alice)
    );

    // Alice generates the secret key based on the prekey bundle and the shared secret
    let mut alice_secret_key_builder: Vec<u8> = vec![];
    alice_secret_key_builder.extend_from_slice(
        &CURVE_TYPE
            .dh(
                &alice_private_bundle.identity_key.private_key,
                &alice_prekey_bundle.curve_prekey.public_key,
            )
            .map_err(|e| GeneralError::DiffieHellman(e))?,
    );
    alice_secret_key_builder.extend_from_slice(
        &CURVE_TYPE
            .dh(
                &alice_ephemeral_key_pair.private_key,
                &alice_prekey_bundle.identity_key,
            )
            .map_err(|e| GeneralError::DiffieHellman(e))?,
    );
    alice_secret_key_builder.extend_from_slice(
        &CURVE_TYPE
            .dh(
                &alice_ephemeral_key_pair.private_key,
                &alice_prekey_bundle.curve_prekey.public_key,
            )
            .map_err(|e| GeneralError::DiffieHellman(e))?,
    );
    if let Some(ot_prekey) = alice_prekey_bundle.one_time_curve_prekey.clone() {
        alice_secret_key_builder.extend_from_slice(
            &CURVE_TYPE
                .dh(&alice_ephemeral_key_pair.private_key, &ot_prekey.public_key)
                .map_err(|e| GeneralError::DiffieHellman(e))?,
        );
    }
    alice_secret_key_builder.extend_from_slice(&shared_secret_alice);
    debug!(
        "Secret key builder (Alice): {}",
        print_slice(&alice_secret_key_builder)
    );
    let alice_secret_key: [u8; 32] = kdf::kdf(
        &alice_secret_key_builder,
        &CURVE_TYPE,
        &PQKEM_TYPE,
        &HASH_TYPE,
        INFO,
    );
    debug!("Secret key (Alice): {}", print_slice(&alice_secret_key));

    // Alice deletes the secret key builder from memory
    alice_secret_key_builder.zeroize();
    debug!("Secret key builder (Alice) deleted");

    // Alice deletes her private ephemeral key
    alice_ephemeral_key_pair.private_key.zeroize();
    debug!("Alice's private ephemeral key deleted");

    // Alice deletes the shared secret from memory
    shared_secret_alice.zeroize();
    debug!("Shared secret (Alice) deleted");

    // Alice computes the associated data
    let mut alice_associated_data: Vec<u8> = vec![];
    alice_associated_data
        .extend_from_slice(&alice_private_bundle.identity_key.public_key.encode_ec());
    alice_associated_data.extend_from_slice(&alice_prekey_bundle.identity_key.encode_ec());
    debug!(
        "Associated data (Alice): {}",
        print_slice(&alice_associated_data)
    );

    // Alice forms the first message
    let (mut ciphertext, nonce) = AEAD_TYPE.encrypt(
        &alice_secret_key,
        "Lorem ipsum dolor sit amet consectetur adipiscing elit quisque faucibus ex sapien vitae pellentesque sem placerat in id cursus mi pretium tellus duis convallis tempus leo eu aenean sed diam urna tempor pulvinar vivamus fringilla lacus nec metus bibendum egestas iaculis massa nisl malesuada lacinia integer nunc posuere ut hendrerit semper vel class aptent taciti sociosqu ad litora torquent per conubia nostra inceptos himenaeos orci varius natoque penatibus et magnis dis parturient montes nascetur ridiculus mus donec rhoncus eros lobortis nulla molestie mattis scelerisque maximus eget fermentum odio phasellus non purus est efficitur laoreet mauris pharetra vestibulum fusce dictum risus.".as_bytes(),
        &alice_associated_data,
        &mut rng,
    ).map_err(|e| GeneralError::AEAD(e))?;
    let first_message = FirstMessage {
        peer_identity_key: alice_private_bundle.identity_key.public_key.clone(),
        peer_ephemeral_key: alice_ephemeral_key_pair.public_key.clone(),
        pqkem_ciphertext: pqkem_ciphertext.to_vec(),
        used_curve_prekey_id: alice_prekey_bundle
            .one_time_curve_prekey
            .clone()
            .map(|x| x.id),
        used_pqkem_prekey_id: alice_prekey_bundle.one_time_pqkem_prekey.id,
        ciphertext: ciphertext.clone(),
        encryption_nonce: nonce.to_vec(),
        encryption_type: AEAD_TYPE.get_type(),
    };
    debug!("First message (Alice):");
    first_message.print();

    // Alice deletes the ciphertext from memory
    ciphertext.zeroize();
    debug!("Ciphertext (Alice) deleted");

    // Bob receives the first message and finds the used prekeys
    let bob_used_pqkem_prekey = bob_private_bundle
        .one_time_pqkem_prekeys
        .iter()
        .find(|x| x.id == first_message.used_pqkem_prekey_id)
        .unwrap();
    let bob_used_curve_prekey = first_message.used_curve_prekey_id.map(|id| {
        bob_private_bundle
            .one_time_curve_prekeys
            .iter()
            .find(|x| x.id == id)
            .unwrap()
    });

    // Bob decapsulates the shared secret
    let mut shared_secret_bob = PQKEM_TYPE.decapsulate(
        &bob_used_pqkem_prekey.key_pair.private_key.bytes,
        &first_message.pqkem_ciphertext,
    )
    .map_err(|e| GeneralError::PQKEM(e))?;
    debug!("Shared secret (Bob): {}", print_slice(&shared_secret_bob));

    // Bob generates the secret key based on the used prekeys and the shared secret
    let mut bob_secret_key_builder: Vec<u8> = vec![];
    bob_secret_key_builder.extend_from_slice(
        &CURVE_TYPE
            .dh(
                &bob_private_bundle.curve_prekey.key_pair.private_key,
                &first_message.peer_identity_key,
            )
            .map_err(|e| GeneralError::DiffieHellman(e))?,
    );
    bob_secret_key_builder.extend_from_slice(
        &CURVE_TYPE
            .dh(
                &bob_private_bundle.identity_key.private_key,
                &first_message.peer_ephemeral_key,
            )
            .map_err(|e| GeneralError::DiffieHellman(e))?,
    );
    bob_secret_key_builder.extend_from_slice(
        &CURVE_TYPE
            .dh(
                &bob_private_bundle.curve_prekey.key_pair.private_key,
                &first_message.peer_ephemeral_key,
            )
            .map_err(|e| GeneralError::DiffieHellman(e))?,
    );
    if let Some(ot_prekey) = bob_used_curve_prekey.clone() {
        bob_secret_key_builder.extend_from_slice(
            &CURVE_TYPE
                .dh(
                    &ot_prekey.key_pair.private_key,
                    &first_message.peer_ephemeral_key,
                )
                .map_err(|e| GeneralError::DiffieHellman(e))?,
        );
    }
    bob_secret_key_builder.extend_from_slice(&shared_secret_bob);
    debug!(
        "Secret key builder (Bob): {}",
        print_slice(&bob_secret_key_builder)
    );
    let bob_secret_key: [u8; 32] = kdf::kdf(
        &bob_secret_key_builder,
        &CURVE_TYPE,
        &PQKEM_TYPE,
        &HASH_TYPE,
        INFO,
    );
    debug!("Secret key (Bob): {}", print_slice(&bob_secret_key));

    // Bob deletes the secret key builder from memory
    bob_secret_key_builder.zeroize();
    debug!("Secret key builder (Bob) deleted");

    // Bob deletes the shared secret from memory
    shared_secret_bob.zeroize();
    debug!("Shared secret (Bob) deleted");

    // Bob constructs the associated data
    let mut bob_associated_data: Vec<u8> = vec![];
    bob_associated_data.extend_from_slice(&first_message.peer_identity_key.encode_ec());
    bob_associated_data.extend_from_slice(&bob_private_bundle.identity_key.public_key.encode_ec());
    debug!(
        "Associated data (Bob): {}",
        print_slice(&alice_associated_data)
    );

    // Bob tries to decrypt the ciphertext
    let nonce_bytes: [u8; 12] = first_message
        .encryption_nonce
        .try_into()
        .map_err(|_| GeneralError::AEAD(AEADError::InvalidNonceSize))?;
    let decrypt_attempt = AEAD_TYPE.decrypt(
        &bob_secret_key,
        &first_message.ciphertext,
        &bob_associated_data,
        &nonce_bytes,
    );
    debug!("Decrypt attempt: {:?}", decrypt_attempt);
    if let Ok(decrypted_bytes) = decrypt_attempt {
        // Reconstruct the message from the bytes
        let bob_message: &str = std::str::from_utf8(&decrypted_bytes).unwrap();
        info!("Decrypted message: {:?}", bob_message);
    }

    Ok(())
}
